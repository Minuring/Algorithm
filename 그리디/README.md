# 그리디
- [분수 배낭 문제](./분수배낭문제.py)

<pre>먼저 <b>무게 당 가격</b>을 기준으로 정렬한다.
<strong>탐욕적으로 같은 무게에 대해 가격이 높은 것부터 담는다.</strong>
현재 담으려는 내용물이 배낭의 총 용량을 초과하면 가능한 만큼 최대로 분할해 담는다.

처음 정렬하는 데에 O(NlogN), 배낭에 담는 데 O(N)의 시간이 소요되므로
총 시간복잡도는 O(NlogN)이다.
</pre>

- [강의실 배정 문제](./강의실배정문제.py)

<pre>입력된 강의 시간들을 시작시간 순으로 정렬한다.
개설 할 강의실 리스트는 이진 힙(최소 힙) 자료구조를 사용하며, 종료시간을 삽입한다.

제한된 시간 내에 강의를 최대한 많이 넣으려면,
<strong>강의는 가능한 한 늦게 시작해 빨리 끝나야한다.</strong>

맨 처음 강의의 <b>종료시간</b>을 먼저 힙에 삽입하고 시작한다.
개설해야할 강의실 리스트는 최소힙이므로, 최소값이 들어있으므로 힙의 루트에는
"항상" 개설된 강의실 중 가장 빨리 끝난 시간이 들어있다.

강의 시간들은 맨 처음에 시작시간 순으로 정렬했다.
강의들을 차례로 heapq의 루트(현재까지 가장 빨리 끝나는 시간)와 비교하고,
전자가 크거나 같으면 (=현재까지 가장 빨리 끝나는 강의 이후에 같은 강의실에서 강의가 가능하면)
강의실 개설을 안 해도되고, 아니면 강의실을 개설한다.

처음 정렬에서 O(NlogN)의 시간이 소요된다.
이진 힙의 삽입은 O(logN)의 시간이 소요된다. (힙 속성 유지)
그리고 강의 개수만큼 반복하며 이 작업이 일어나기에,
총 시간복잡도는 O(2*NlogN) = O(NlogN)이다.

</pre>

- [초 증가 순서](./초%20증가%20순서.py)

`문제 : 초 증가 순서인 입력에서 어떤 숫자들을 선택해야 합이 K가 될까?`

<pre>입력을 정렬해서 큰 수부터 시작해 내림차순으로 반복한다.
현재 숫자가 K보다 크면 건너뛰고, 같거나 작으면, 선택하고 K에서 숫자를 뺀다.
위 과정을 K가 0이 될 때까지 반복한다.

결국 동전 교환문제와 같은 문제이다.
비교 연산을 반드시 N번 해야 한다. 시간복잡도는 O(N)이다.
</pre>

- [프림 알고리즘](./프림%20알고리즘.py)

<pre>1.시작 정점을 정해 리스트에 추가한다.
2. 리스트에 있는 모든 정점들과 연결된 모든 정점 중 가장 가까운 점을 연결한다.
- 이때 이미 포함된 정점은 제외한다.
위 2번을 (정점 수 -1)번 반복한다.

첫 정점까지 포함해 V번의 반복 속에서, 점을 연결할 때마다 새로 연결한 점과 연결된
모든 정점과의 거리를 갱신해야하므로 V번 반복이 일어난다. ( V:정점 개수)
따라서 시간 복잡도는 O(V^2)이다.
</pre>

- [프림 알고리즘 (이진힙)](./프림%20알고리즘%20이진힙.py)

<pre>바로 위 O(V^2)인 알고리즘에서 새로운 점이 추가될 때마다 V번 반복이 일어난다.
이는 V와 연결된 최소거리를 찾는 시간인데, 연결된 점을 추가할 때 가중치에 대한 최소 힙으로 넣으면,
넣는 과정에서 O(log N), 이 정점과 연결된 최소 거리를 O(1)에 얻을 수 있다.

따라서 프림 알고리즘을 이진힙을 사용해 구현하면 시간복잡도는 O(NlogN)이다.
</pre>

- [크루스칼 알고리즘](크루스칼%20알고리즘.py)
<pre>간선들을 가중치를 기준으로 정렬한다.
간선 개수만큼 (가중치가 작은 간선부터) 다음을 반복한다.
공통된 부모노드를 가지지 않으면(=연결 시 사이클이 형성되지 않으면) 연결한다.

사이클을 판단하는 방법
    부모노드 배열을 정점 개수만큼 각 정점으로 초기화한다.
    간선 연결시마다 두 정점 중 큰 정점의 부모노드를 작은 정점의 부모노드로 갱신한다.
</pre>

- [다익스트라 알고리즘](다익스트라%20알고리즘.py)
<pre>시작점의 거리를 0, 기방문 처리하고 다음을 정점 개수 V만큼 반복한다.
시작점으로부터 다른 모든 정점까지의 거리 배열 dist에서 방문하지 않은 정점 중 최소값을 찾아 방문한다.
해당 정점에서 갈 수 있는 다른 모든 정점들의 거리를, 기존 거리와 해당 정점을 거쳐서 가는 거리 중 최소값으로 갱신한다.

이진 힙으로 구현할 때 :
이진 힙에서 POP하여 최소거리의 정점을 얻는다.
( 이 때, 가중치가 dist배열의 해당 정점의 거리값보다 크면 건너뛴다. 어차피 볼 필요가 없고, 또는 이미 방문한 경우이기 때문)
해당 정점에서 갈 수 있는 정점 중 해당 정점을 거쳐가는 게 가중치가 작으면,
    해당 간선을 이진힙에 가중치를 키로 넣고 거리를 갱신한다.

첫 번째 방법으로 구현하면 시간복잡도는 O(V^2)이다.
( 최악의 경우 == 모든 노드가 서로 연결되있을 때 : 한 정점에서 간선 개수는 V-1 )
이진 힙으로 구현하면 시간복잡도는 O(E*logV)이다.
</pre>