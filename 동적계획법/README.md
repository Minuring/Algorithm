# 동적계획법
- [동전 교환 문제 (TopDown)](동전%20교환%20문제.py)

<pre>memo 배열을 1 단위로 총 액수까지 만들어 두고, -1로 초기화하고 시작한다.
잔액이 0이면 0을 반환, 잔액이 0보다 작으면 inf를 반환한다.
memo[money] != -1 이면, 즉 현재 액수가 이미 구해져 있다면 그 값을 리턴한다.

동전 액면가 <b>각각의 액수</b>를 <b>현재 액수에서 뺀 액수</b>에서의 최소 동전개수를 구해, 그 중 최소값을 찾아 저장한다.
그 최소값을 리턴한다.

M원을 n개 액면가로 구성된 동전들로 교환할 때, 동전 액면가 개수만큼 (n), 1원부터 M원까지 고려하기 때문에
시간복잡도는 O(nM)이다.
</pre>


- [동전 교환 문제 (BottomUp)](동전%20교환%20문제%20BottomUp.py)

<pre>dp 배열을 -1로 교환할 액수만큼 만든다.
1(원)부터 ,,, m원,,, M(원)까지 다음을 반복한다.
각각 액면가의 동전 액수 i에 대해, i >= m 일 때 (동전액면가가 현재 액수 이상일 때, 
즉 현재 i원짜리 동전으로 교환 가능할 때),  (*)<b>dp[m]과 dp[m-i]+1 중 최소값을 선택</b>한다.
즉 m원에서 i원 각각을 뺀 액면가들 중 최소 개수를 선택한다.

1~M원에 대해 각 액수마다 동전 액면가 개수 n만큼 반복한다. 따라서 시간복잡도는 O(nM)이다.

(*) Q. 액수가 크면 m-i가 작아지니까 최소값을 꼭 비교하지 않아도 최소값이 되는 것 아닌가?
    dp[m] = dp[m-i]+1로 최소값 비교를 하지 않고 갱신할 경우 :
    반례 : coin = [1,5,12] money = 15
    i=0(1원짜리)일때 dp[15] = dp[14]+1 = 3+1 = 4
    i=1(5원짜리)일때 dp[15] = dp[10]+1 = 2+1 = 3
    i=2(12원짜리)일때 dp[15] = dp[3]+1 = 3+1 = 4
    최적해 dp[15] = 3, 위 예에서 구한 해 : 4
    
</pre>


- [0-1 배낭문제 (TopDown)](01배낭문제%20TopDown.py)

<pre>n개의 물품을 K용량의 배낭에 넣는 최대 이익은 다음과 같다.
- 물품이 없거나 용량이 없으면 0이다.
- 물품의 용량이 배낭의 용량보다 크면 해당 물품을 제외한 나머지 물품들을 K용량에 넣는 최대이익이다.
- 물품의 용량이 배낭의 용량 이하면 해당 물품을 넣었을 때 최대이익, 해당 물품을 뺐을 때 최대이익 중 최대값이다.

이를 재귀로 풀게 되면 중첩된 부문제들이 생긴다. 따라서 DP로 해결한다.

재귀 트리의 높이는 반드시 O(n)이다. 그리고 매 단계마다 물품을 넣거나 빼거나 즉 2가지 노드가 생긴다.
따라서 단순 재귀 트리의 노드 개수는 2^n-1 이고, DP로 해결하면 n개 물품에 대해 1~K용량에 대해 고려하기 때문에
시간복잡도는 O(nK)이다.
</pre>

- [0-1 배낭문제 (BottomUp)](01배낭문제%20BottomUp.py)

<pre>dp 배열을 0~K(배낭용량)만큼 0으로 초기화하여 만든다.
n개 물품을 K용량의 배낭에 넣는 최대이익은 다음과 같다.
각 물품에 대해(n번), 각 배낭 용량 i(0~K)에 대해(K번),
dp[i]에 < dp[i] > 와 < dp[i - (현재물품의무게)] + (현재물품의 가격) > 중 최대값을 할당한다.
즉, 이전 물품까지 고려했을때 배낭용량 i에서 최대이익과, 현재 물품을 고려했을 때 최대이익을 비교한다.

최종적으로 용량 K배낭에서 최대이익은 dp[K]이다.

물품 개수만큼, 배낭용량 0~K만큼 비교하므로 시간복잡도는 O(nK)이다.
</pre>

    - 0-1 배낭문제 인덱스 별 2차원 배열, 1차원 배열 비교
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 100, 100, 100], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 100, 100, 100], [0, 0, 200, 200, 200, 300], [0, 0, 0, 0, 0, 0]]
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 100, 100, 100], [0, 0, 200, 200, 200, 300], [0, 0, 300, 300, 500, 500]]
    500
    //2차원 배열 인덱스 j를 물품 무게부터 시작
    
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 100, 100, 100], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 100, 100, 100], [0, 0, 200, 200, 200, 300], [0, 0, 0, 0, 0, 0]]
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 100, 100, 100], [0, 0, 200, 200, 200, 300], [0, 0, 300, 300, 500, 500]]
    500
    //2차원 배열 인덱스 j를 0부터 시작
    
    [0, 0, 0, 0, 0, 0]
    [0, 0, 0, 100, 100, 100]
    [0, 0, 200, 200, 200, 300]
    [0, 0, 300, 300, 500, 500]
    500
    //1차원 배열로 M->물품무게까지 -1씩 덮어쓰기

    2차원 배열로 할 때 인덱스를 물품 무게부터 시작하는 것이 아무래도 더 빠를것이다.
    1차원 배열로 이전 물품까지 최대값을 바꿔가면서 해도 결과는 같음. << 공간복잡도 감소

- [벨만 포드 알고리즘](벨만%20포드%20알고리즘.py)

<pre>시작점을 제외한 n-1개의 정점에 대해, <b>모든 간선의 간선완화</b>를 수행한다.
즉 모든 간선을 완화하는 작업을 n-1번 수행한다.

간선 완화는 다익스트라 알고리즘과 비슷하게, 모든 각 정점에 대해 기존의 거리와 정점을 거친 경로를 비교한다.
한 번의 반복마다 한 정점까지의 거리가 <b>확정</b>되는 다익스트라 알고리즘과 달리,
확정하지 않고 매 반복마다 간선완화를 진행하기 때문에 간선의 음수 가중치 반영할 수 있고,
N-1번 반복했을 때에는 모든 음수 가중치를 반영할 수 있다.
( 매 반복마다 모든 간선을 확인하기 때문에 음수 가중치를 반영하고, 이를 N-1번 반복하기 때문)

+ N-1번 반복한 후에도 간선 완화가 진행되면 음의 사이클이 존재하는 것이다.

정점 개수 -1(V) * 간선 개수(E) 만큼 반복하므로, 시간복잡도는 O(V*E)이다.
이진 힙으로 구현한 다익스트라 알고리즘 O(E*logV)에 비해 느리지만, 음수 가중치를 처리할 수 있다.
</pre>

- [가장 긴 증가 순서](가장%20긴%20증가%20순서.py)

<pre>숫자들의 배열을 다음과 같이 그래프로 만든다.
왼쪽에서부터 오른쪽으로, 현재 숫자의 왼쪽에 있는 모든 숫자들에 대해
현재 숫자가 더 크면 작은 숫자의 인덱스를 추가한다.
그래프 관점에서 말하면, <b>현재 숫자로 진입</b>하는 간선의 시작정점을 추가한다.

거리 배열을 1로 초기화한다. (가장 짧은 증가 순서는 1이기 때문)
previous배열을 -1로 초기화한다. (순서를 기록하기 위함)
숫자 배열의 모든 숫자들에 대해 왼쪽부터 오른쪽으로 가면서 다음을 수행한다.
    현재 숫자(i번째)로 도달하는 숫자들(v번째) 중 최소 길이를 찾는다.
    이 때, 최소 길이를 찾을때마다 previous[i] = v로 갱신하여, 순서를 기록한다.
    ( i번째 숫자 이전 숫자는 v번째 숫자 )

    i번째 숫자의 길이는 위에서 찾은 최소 길이 +1 이다.

숫자들이 최악의 경우 1,2,3,4,5,,와 같이 오름차순으로 되어있을 때,
배열 길이 N번, 각각 1, 2, ,, N-1번 반복하므로(그래프의 간선수 또한 n(n-1)/2),
시간복잡도는 O(N^2)이다.
</pre>

- [편집 거리](편집거리%20알고리즘.py)

<pre>문자열 A에서 문자열 B로 변경되기 위한 최소 편집(삽입,삭제,대체) 횟수
2차원 배열 (행 : 0~A의길이, 열 : 0~B의길이) 을 만들고 이를 채워나간다.
dp[i][j] 는 A의 1~i번째까지를 B의 1~j번째까지의 문자로 편집하는 최소편집거리이다.
ex) [A] MICROSOFT -> [B] NCSOFT
dp[4][3] = "MICR" -> "NCS" 로 바꾸는 최소 편집거리

0번째 행 dp[0][j] 는 "" -> ""~"NCSOFT" 이므로 dp[0][j] = j 즉 0,1,,,len(B)이다.
0번째 열 dp[i][0] 는 ""~"MICROSOFT" -> "" 이므로 dp[i][0] = i 즉 0,1,,,len(A)이다.

<strong>dp[i][j] =</strong> 
    
    if Ai == Bj 이면 즉 (A의 i번째문자 == B의 j번째문자) 이면 A의 i번째문자를 B의 j번째문자로 <b>변경할 필요가 없다.</b>
        dp[i-1][j-1]
    
    else (Ai != Bj 이면)
        (Ai ->B_j-1까지 편집 후 Bj삽입) : dp[i][j-1] + 1
        (A_i-1 ->B_j-1까지 편집 후 Ai대체) : dp[i-1][j-1] + 1
        (A_i-1 ->B_j까지 편집 후 Ai삭제) : dp[i-1][j] + 1
        위 3가지 경우 중 최소값

<b>이다.</b>

2차원배열 크기만큼 비교연산을 수행하므로 시간복잡도는 A의길이*B의길이이다. O(NM)
</pre>
