# 동적계획법
- [동전 교환 문제 (TopDown)](동전%20교환%20문제.py)

<pre>memo 배열을 1 단위로 총 액수까지 만들어 두고, -1로 초기화하고 시작한다.
잔액이 0이면 0을 반환, 잔액이 0보다 작으면 inf를 반환한다.
memo[money] != -1 이면, 즉 현재 액수가 이미 구해져 있다면 그 값을 리턴한다.

동전 액면가 <b>각각의 액수</b>를 <b>현재 액수에서 뺀 액수</b>에서의 최소 동전개수를 구해, 그 중 최소값을 찾아 저장한다.
그 최소값을 리턴한다.

M원을 n개 액면가로 구성된 동전들로 교환할 때, 동전 액면가 개수만큼 (n), 1원부터 M원까지 고려하기 때문에
시간복잡도는 O(nM)이다.
</pre>


- [동전 교환 문제 (BottomUp)](동전%20교환%20문제%20BottomUp.py)

<pre>dp 배열을 -1로 교환할 액수만큼 만든다.
1(원)부터 ,,, m원,,, M(원)까지 다음을 반복한다.
각각 액면가의 동전 액수 i에 대해, i >= m 일 때 (동전액면가가 현재 액수 이상일 때, 
즉 현재 i원짜리 동전으로 교환 가능할 때),  (*)<b>dp[m]과 dp[m-i]+1 중 최소값을 선택</b>한다.
즉 m원에서 i원 각각을 뺀 액면가들 중 최소 개수를 선택한다.

1~M원에 대해 각 액수마다 동전 액면가 개수 n만큼 반복한다. 따라서 시간복잡도는 O(nM)이다.

(*) Q. 액수가 크면 m-i가 작아지니까 최소값을 꼭 비교하지 않아도 최소값이 되는 것 아닌가?
    dp[m] = dp[m-i]+1로 최소값 비교를 하지 않고 갱신할 경우 :
    반례 : coin = [1,5,12] money = 15
    i=0(1원짜리)일때 dp[15] = dp[14]+1 = 3+1 = 4
    i=1(5원짜리)일때 dp[15] = dp[10]+1 = 2+1 = 3
    i=2(12원짜리)일때 dp[15] = dp[3]+1 = 3+1 = 4
    최적해 dp[15] = 3, 위 예에서 구한 해 : 4
    
</pre>


- [0-1 배낭문제 (TopDown)](01배낭문제%20TopDown.py)

<pre>n개의 물품을 K용량의 배낭에 넣는 최대 이익은 다음과 같다.
- 물품이 없거나 용량이 없으면 0이다.
- 물품의 용량이 배낭의 용량보다 크면 해당 물품을 제외한 나머지 물품들을 K용량에 넣는 최대이익이다.
- 물품의 용량이 배낭의 용량 이하면 해당 물품을 넣었을 때 최대이익, 해당 물품을 뺐을 때 최대이익 중 최대값이다.

이를 재귀로 풀게 되면 중첩된 부문제들이 생긴다. 따라서 DP로 해결한다.

재귀 트리의 높이는 반드시 O(n)이다. 그리고 매 단계마다 물품을 넣거나 빼거나 즉 2가지 노드가 생긴다.
따라서 단순 재귀 트리의 노드 개수는 2^n-1 이고, DP로 해결하면 n개 물품에 대해 1~K용량에 대해 고려하기 때문에
시간복잡도는 O(nK)이다.
</pre>

- [0-1 배낭문제 (BottomUp)](01배낭문제%20BottomUp.py)

<pre>dp 배열을 0~K(배낭용량)만큼 0으로 초기화하여 만든다.
n개 물품을 K용량의 배낭에 넣는 최대이익은 다음과 같다.
각 물품에 대해(n번), 각 배낭 용량 i(0~K)에 대해(K번),
dp[i]에 < dp[i] > 와 < dp[i - (현재물품의무게)] + (현재물품의 가격) > 중 최대값을 할당한다.
즉, 이전 물품까지 고려했을때 배낭용량 i에서 최대이익과, 현재 물품을 고려했을 때 최대이익을 비교한다.

최종적으로 용량 K배낭에서 최대이익은 dp[K]이다.

물품 개수만큼, 배낭용량 0~K만큼 비교하므로 시간복잡도는 O(nK)이다.
</pre>

    - 0-1 배낭문제 인덱스 별 2차원 배열, 1차원 배열 비교
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 100, 100, 100], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 100, 100, 100], [0, 0, 200, 200, 200, 300], [0, 0, 0, 0, 0, 0]]
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 100, 100, 100], [0, 0, 200, 200, 200, 300], [0, 0, 300, 300, 500, 500]]
    500
    //2차원 배열 인덱스 j를 물품 무게부터 시작
    
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 100, 100, 100], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 100, 100, 100], [0, 0, 200, 200, 200, 300], [0, 0, 0, 0, 0, 0]]
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 100, 100, 100], [0, 0, 200, 200, 200, 300], [0, 0, 300, 300, 500, 500]]
    500
    //2차원 배열 인덱스 j를 0부터 시작
    
    [0, 0, 0, 0, 0, 0]
    [0, 0, 0, 100, 100, 100]
    [0, 0, 200, 200, 200, 300]
    [0, 0, 300, 300, 500, 500]
    500
    //1차원 배열로 M->물품무게까지 -1씩 덮어쓰기

    2차원 배열로 할 때 인덱스를 물품 무게부터 시작하는 것이 아무래도 더 빠를것이다.
    1차원 배열로 이전 물품까지 최대값을 바꿔가면서 해도 결과는 같음. << 공간복잡도 감소

- [벨만 포드 알고리즘](벨만%20포드%20알고리즘.py)

<pre>시작점을 제외한 n-1개의 정점에 대해, <b>모든 간선의 간선완화</b>를 수행한다.
즉 모든 간선을 완화하는 작업을 n-1번 수행한다.

간선 완화는 다익스트라 알고리즘과 비슷하게, 모든 각 정점에 대해 기존의 거리와 정점을 거친 경로를 비교한다.
한 번의 반복마다 한 정점까지의 거리가 <b>확정</b>되는 다익스트라 알고리즘과 달리,
확정하지 않고 매 반복마다 간선완화를 진행하기 때문에 음수 사이클을 반영할 수 있고,
N-1번 반복했을 때에는 모든 음수 가중치를 반영할 수 있다.
( 매 반복마다 모든 간선을 확인하기 때문에 음수 가중치를 반영하고, 이를 N-1번 반복하기 때문)

+ N-1번 반복한 후에도 간선 완화가 진행되면 음의 사이클이 존재하는 것이다.

정점 개수 -1(V) * 간선 개수(E) 만큼 반복하므로, 시간복잡도는 O(V*E)이다.
이진 힙으로 구현한 다익스트라 알고리즘 O(E*logV)에 비해 느리지만, 음수 가중치를 처리할 수 있다.
</pre>