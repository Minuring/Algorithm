# 동적계획법
- [동전 교환 문제 (TopDown)](동전%20교환%20문제.py)

<pre>memo 배열을 1 단위로 총 액수까지 만들어 두고, -1로 초기화하고 시작한다.
잔액이 0이면 0을 반환, 잔액이 0보다 작으면 inf를 반환한다.
memo[money] != -1 이면, 즉 현재 액수가 이미 구해져 있다면 그 값을 리턴한다.

동전 액면가 **각각의 액수**를 **현재 액수에서 뺀 액수**에서의 최소 동전개수를 구해, 그 중 최소값을 찾아 저장한다.
그 최소값을 리턴한다.

M원을 n개 액면가로 구성된 동전들로 교환할 때, 동전 액면가 개수만큼 (n), 1원부터 M원까지 고려하기 때문에
시간복잡도는 O(nM)이다.
</pre>


- [동전 교환 문제 (BottomUp)](동전%20교환%20문제%20BottomUp.py)

<pre>dp 배열을 -1로 교환할 액수만큼 만든다.
1(원)부터 ,,, m원,,, M(원)까지 다음을 반복한다.
각각 액면가의 동전 액수 i에 대해, i >= m 일 때 (동전액면가가 현재 액수 이상일 때, 
즉 현재 i원짜리 동전으로 교환 가능할 때),  (*)**dp[m]과 dp[m-i]+1 중 최소값을 선택**한다.
즉 m원에서 i원 각각을 뺀 액면가들 중 최소 개수를 선택한다.

1~M원에 대해 각 액수마다 동전 액면가 개수 n만큼 반복한다. 따라서 시간복잡도는 O(nM)이다.

(*) Q. 액수가 크면 m-i가 작아지니까 최소값을 꼭 비교하지 않아도 최소값이 되는 것 아닌가?
    dp[m] = dp[m-i]+1로 최소값 비교를 하지 않고 갱신할 경우 :
    반례 : coin = [1,5,12] money = 15
    i=0(1원짜리)일때 dp[15] = dp[14]+1 = 3+1 = 4
    i=1(5원짜리)일때 dp[15] = dp[10]+1 = 2+1 = 3
    i=2(12원짜리)일때 dp[15] = dp[3]+1 = 3+1 = 4
    최적해 dp[15] = 3, 위 예에서 구한 해 : 4
    
</pre>


- [0-1 배낭문제 (TopDown)](01배낭문제%20TopDown.py)

<pre>n개의 물품을 K용량의 배낭에 넣는 최대**이익**은 다음과 같다.
- 물품이 없거나 용량이 없으면 0이다.
- 물품의 용량이 배낭의 용량보다 크면 해당 물품을 제외한 나머지 물품들을 K용량에 넣는 최대이익이다.
- 물품의 용량이 배낭의 용량 이하면 해당 물품을 넣었을 때 최대이익, 해당 물품을 뺐을 때 최대이익 중 최대값이다.

이를 재귀로 풀게 되면 중첩된 부문제들이 생긴다. 따라서 DP로 해결한다.

재귀 트리의 높이는 반드시 O(n)이다. 그리고 매 단계마다 물품을 넣거나 빼거나 즉 2가지 노드가 생긴다.
따라서 단순 재귀 트리의 노드 개수는 2^n-1 이고, DP로 해결하면 n개 물품에 대해 1~K용량에 대해 고려하기 때문에
시간복잡도는 O(nK)이다.
</pre>

- [0-1 배낭문제 (BottomUp)](01배낭문제%20BottomUp.py)

<pre>dp 배열을 0~K(배낭용량)만큼 0으로 초기화하여 만든다.
n개 물품을 K용량의 배낭에 넣는 최대**이익**은 다음과 같다.
각 물품에 대해(n번), 각 배낭 용량 i(0~K)에 대해(K번),
dp[i]에 < dp[i] > 와 < dp[i - (현재물품의무게)] + (현재물품의 가격) > 중 최대값을 할당한다.
즉, 이전 물품까지 고려했을때 배낭용량 i에서 최대이익과, 현재 물품을 고려했을 때 최대이익을 비교한다.

최종적으로 용량 K배낭에서 최대이익은 dp[K]이다.

물품 개수만큼, 배낭용량 0~K만큼 비교하므로 시간복잡도는 O(nK)이다.
</pre>

